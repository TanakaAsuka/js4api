# 变量、作用域与内存
本章节基础概念比较多而且比较重要，没有相应的API。
## 原始值与引用值
### 传递参数
> ECMAScript中所有函数的参数都是按值传递的，变量可以按值和按引用访问，而传参则只能按值传递

### 确定类型
- typeof操作符最适合用来判断一个变量是否为原始类型，包括字符串、数值、布尔值或undefined，除了null。如果值是对象或null，那么typeof返回object，注意null是原始类型。
 
- 对于引用类型，可以使用instanceof，如果变量是给定引用类型（由其原型链决定）的实例，则instanceof操作符返回true。如果用instanceof检测原始值，则始终会返回false，因为原始值不是对象。

## 执行上下文与作用域
- 变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable  object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。
 
- 全局上下文是最外层的上下文。根据ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的window对象（第12章会详细介绍），因此所有通过var定义的全局变量和函数都会成为window对象的属性和方法。
 
- 使用let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。
 
- 每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。
 
- 上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation  object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。
 
- 代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）

### 作用域链增强
- 然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。
 
- 这些语句包括:
> - try/catch语句的catch块
> - with语句
 
- 这两种情况下，都会在作用域链前端添加一个变量对象。对with语句来说，会向作用域链前端添加指定的对象；对catch语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。

## 内存管理
- 优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再需要，那么把它设置为null，从而释放其引用。这也可以叫作解除引用。这个建议最适合**全局变量**和全局对象的**属性**

### 隐藏类和删除操作
- Chrome的V8引擎在将解释后的JavaScript代码编译为实际的机器码时会利用“隐藏类”。
 
- 运行期间，V8会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8会针对这种情况进行优化，但不一定总能够做到。

### 内存泄漏
- 意外声明全局变量是最常见但也最容易修复的内存泄漏问题

- 定时器也可能会悄悄地导致内存泄漏

###  静态分配与对象池
- 减少浏览器执行垃圾回收的次数可以提升javascript的性能
 
- 开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能（提升性能）。
 
- 浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样会影响性能。
 
- 上面这种情况可以使用对象池进行优化，在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。

- 如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。这个对象池必须使用某种结构维护所有对象，数组是比较好的选择。